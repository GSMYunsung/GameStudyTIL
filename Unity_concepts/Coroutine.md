#### 코루틴



**코루틴과 쓰레드**

---



닷넷은 멀티쓰레드를 지원하지만 닷넷을 사용하는 유니티는 `단일 쓰레드`로 동작한다.

**[만약 단일 쓰레드를 사용하는 유니티에서 멀티쓰레드코드를 작성한다면?]**

```
 버그 발생률이 높아지고 멀티쓰레드간 교착 상태 경합 등, 신경써야 할 부분이 많아진다. 
```

따라서 단일 쓰레드를 사용하는것이 좋다.   <br>

하지만 꼭 멀티쓰레드 코드를 작성해야하는 일이 생긴다면 대처하지 못할 수도있다.  <br>

여기서 이것을 해결해 주는 것이 `유니티 코루틴(Coroutine)`이다.   <br>

`일반적인 쓰레드 방식의 프로그래밍`을 유니티에서는 코루틴을 사용함으로써 `멀티 쓰레드를 흉내` 를 낼 수 있다.



**코루틴의 동작방식**

---



꼭 멀티쓰레드를 써야할때 쓰레드를 사용하지 않고  멀티 테스킹을 가능하게 한다.  <br>

`어떤방법으로 구현할 수있을까?`

코루틴 함수가 IEnumerator 를 반환하는데 힌트를 얻을 수있다.<br>

```
일반적으로 함수가 호출되서 끝나는 일반적인 함수의 서브루틴의 개념과 달리 
yield return을사용함으로 그 위치를 기억하고 다음 호출 때 그곳부터 다음을 실행 할 수있도록 하는 것이다.
```

 그래서 여러개의 코루틴을 동작시키고 각기다른 시점에 yield가 반환되도록 한다면 마치 어러개의 쓰래드가 동시에 동작하는것과 같은 효과가 나타난다. <br>

유니티의 Update 함수는 1프래임에 한 번 호출 된다. <br>

매 프래임마다 yield return 할 코루틴이 있는지 체크하는데 코루틴의 yield 종류마다 그 시점이 다르다.  하지만

대부분은 Update 에서 체크된다. <br>



**코루틴의 종류**

---



```
yield 코루틴은 다음 프레임에서 모든 Update 함수가 호출된 후에 속행합니다.
```

[yield WaitForSeconds]  : 프레임에 대한 모든 Update 함수가 호출된 후 `지정된 시간 지연 후`에 속행합니다.

[yield WaitForFixedUpdate] :  모든 스크립트에서 모든 `FixedUpdate 호출 후` 속행합니다.

[yield WWW WWW] : `다운로드 완료 후 속행`합니다.

[yield StartCoroutine]  : 코루틴을 연결하고 *`MyFunc 코루틴`이 먼저 완료될 때까지 기다립니다.



**Coroutine 과 Invoke **

---



[Invoke]

함수를 원하는시점에 호출할 수있도록 해주는 함수이다. 

내부적으로 `타이머에 의해 해당 시간이 되었는지 체크`하여 시간이 되면 호출하는 방식이다.

파라미터를 전달할 수없다.

[Coroutine]

매 프래임마다 체크하여 돌아갈 지점으로 돌아가는 방식이다.



즉, invoke는 시간을 재서 해당 시간이 되면 함수를 실행하는 것이고, 

Coroutine은 하나의 함수 내에서 원하는 `리턴 포인트(목표점)`를 찍고 외부로 수행 권한을 넘긴다.

그런 후 조건이 충족(시간이 다 된다면)되면 다시 넘겼던 포인트 함수로 되돌아 오게 되는것이다.



**코루틴 사용**

---



[1초마다 로그를 찍는 코루틴 함수]

```
//1초마다 로그를 찍는다
private IEnumerator logPrint()
{  
	while (true)  
		{ 
		yield return new WaitForSeconds(1);
        Debug.Log("Coroutine Test!");  
        }
}
```

이 코드를 StartCoroutine(logPrint());  Update함수에서 불러오면 된다.

이 코드에서 만약 코루틴을 사용하지 않았다면 Update함수에서 1초를 일일이 확인해 찍어줬어야 할것이다.

따라서 코루틴은 `짧은코드와 가독성도 좋은 코드로 만들 수있는 함수` 로 볼수있다. 



**코루틴 중지(StopCoroutine)**

---



다음과 같은 방법들로 루프가 걸려있는 코루틴을 중지 시킬 수있다.

```
StopCoroutine로 코루틴을 종료시킨다.

루프를 카운트하여 while 문의 조건문을 체크 하여 루프를 빠저나가도 코루틴은 종료된다.

while 루프를 break;로 빠져나가도 종료된다.

while 루프안에서 yield break; 로도 코루틴을 벗어날 수있다.

StartCoroutine을 호출하는 스크립트가 붙은 오브젝트가 비활성화 되거나 파괴 된다면 역시 종료된다.
```



**코루틴 안에 코루틴 **

---



![img](https://cdn.discordapp.com/attachments/804184517644386345/810170033014964254/unknown.png)

위 그림에서 Funciton0은 로그 Hello world 0을 출력

코루틴으로 Function1를 호출 후 다시 로그로 Hello world 1을 출력

Fuction1에서는 yield return null 을 이용하여 한 프래임을 대기하고 Hello world 1 로그를 출력

[로그 출력 순서는 Hello world 0, Hello world 1,Hello world 2 순서로 출력하게 된다.]

여기서 0,2,1순으로 출력하려먼 어떻게 해야할까? 

![img](https://cdn.discordapp.com/attachments/804184517644386345/810170143451774996/unknown.png)

다음과같이 Fuciton0을 IEnumerator를 반환하도록 하고 Fuciton0에서 Fuciton1을 호출 할 때 `yield return`으로 코루틴을 실행하였다. 이렇게 하면 Hello world 0, Hello world 2,Hello world 1순서로 로그가 출력되게 된다. 코루틴의 특성인 `돌아갈 위치를 기억하고 돌아가는 기능`이 있기 때문이다.



**코루틴 사용 주의사항**

---



1. 코루틴 함수는 일반함수처럼 호출하면 실행되지 않는다. 또한 에러는 커녕 경고조차 뜨지않는다. 

   따라서 반드시 `StartCoroutine 을 사용해 호출 `해야한다.

2. `코루틴은 Time scale의 영향을 받는다.` 예를 들어 Time scale이 1인상태에서 WaitForSeconds(1)을 하였다면 1초를 대기하지만  Time scale 값이 0.5일 때에는 2초 대기를 하게된다.

3. StartCoroutine을 호출하는 스크립트가 붙은 `오브젝트가 비활성화 되거나 파괴`되면 코루틴은 중단된다.
